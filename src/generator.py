import os
import random
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from utils import weights_init

class G_args(object):
    def __init__(self, 
                 vocab_size=3000, 
                 emb_dim=300, 
                 hidden_dim=[3,4,5], 
                 dropout=0.2):
        self.vocab_size = vocab_size
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.num_filters = num_filters 
        self.dropout = dropout

class Generator(nn.Module):
    '''
    Generator
    '''
    def __init__(self, G_args, use_cuda=False):
        super(Generator, self).__init__()
        self.args = G_args
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.use_cuda = use_cuda
        self.emb = nn.Embedding(self.args.vocab_size, self.args.emb_dim)
        self.lstm = nn.LSTM(self.args.emb_dim, self.args.hidden_dim, batch_first=True)
        self.fc = nn.Linear(self.args.hidden_dim, self.args.vocab_size)
        self.softmax = nn.LogSoftmax()
        self.apply(weights_init)

    def forward(self, x):
        """
        Args:
            x: (batch_size, seq_len), sequence of tokens generated by generator
        """
        emb = self.emb(x)
        h0, c0 = self.init_hidden(x.size(0))
        output, (h, c) = self.lstm(emb, (h0, c0))
        pred = self.softmax(self.fc(output.contiguous().view(-1, self.args.hidden_dim)))
        return pred

    def step(self, x, h, c):
        """
        Args:
            x: (batch_size,  1), sequence of tokens generated by generator
            h: (1, batch_size, hidden_dim), lstm hidden state
            c: (1, batch_size, hidden_dim), lstm cell state
        """
        emb = self.emb(x)
        output, (h, c) = self.lstm(emb, (h, c))
        pred = F.softmax(self.fc(output.view(-1, self.args.hidden_dim)), dim=1)
        return pred, h, c

    def init_hidden(self, batch_size):
        h = torch.zeros((1, batch_size, self.args.hidden_dim))
        c = torch.zeros((1, batch_size, self.args.hidden_dim))
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return h, c

    def sample(self, batch_size, seq_len, x=None):
        res = []
        flag = False # whether sample from zero
        if x is None:
            flag = True
        if flag:
            x = torch.zeros((batch_size, 1)).long()
        if self.use_cuda:
            x = x.cuda()
        h, c = self.init_hidden(batch_size)
        samples = []
        if flag:
            for i in range(seq_len):
                output, h, c = self.step(x, h, c)
                x = output.multinomial(1)
                samples.append(x)
        else:
            given_len = x.size(1)
            lis = x.chunk(x.size(1), dim=1)
            for i in range(given_len):
                output, h, c = self.step(lis[i], h, c)
                samples.append(lis[i])
            x = output.multinomial(1)
            for i in range(given_len, seq_len):
                samples.append(x)
                output, h, c = self.step(x, h, c)
                x = output.multinomial(1)
        output = torch.cat(samples, dim=1)
        return output
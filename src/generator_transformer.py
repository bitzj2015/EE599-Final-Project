import os
import random
import math
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from utils import weights_init, TransformerModel


class Gen_args(object):
    def __init__(self, 
                 vocab_size=3000, 
                 emb_dim=300, 
                 nhead=64,
                 nhid=64,
                 num_encode_layers=0.5,
                 num_decode_layers=64,
                 dropout=0.5):
        self.vocab_size = vocab_size
        self.emb_dim = emb_dim
        self.nhead = nhead
        self.nhid = nhid
        self.num_encode_layers = num_encode_layers
        self.num_decode_layers = num_decode_layers
        self.dropout = dropout

class Generator(nn.Module):
    '''
    Generator
    '''
    def __init__(self, G_args, use_cuda=False):
        super(Generator, self).__init__()
        self.args = G_args
        self.use_cuda = use_cuda
        # Encoder
        self.transform = TransformerModel(self.args.vocab_size, 
                                          self.args.emb_dim, 
                                          self.args.nhead, 
                                          self.args.nhid,
                                          self.args.num_encode_layers,
                                          self.args.num_decode_layers, 
                                          self.args.dropout)

        self.apply(weights_init)


    def forward(self, input):
        """
        Args:
            x: (batch_size, seq_len, 2), sequence of tokens generated by generator
        """
        x = input[:,:,0]
        output, encoder = self.transform(x)
        pred = F.log_softmax(output, dim=1)
        pred = pred.view(-1, self.args.vocab_size)
        return pred


    def forward_with_noise(self,
                           input,
                           privatizer):
        """
        Args:
            x: (batch_size, seq_len, 2), sequence of tokens generated by generator
        """
        return None, None

    def sample_with_noise(self, batch_size, input, privatizer):
        return None, None


    def sample(self, batch_size, x_gen, target):

        return None, None

    # def step(self, input, h, c):
    #     """
    #     Args:
    #         x: (batch_size,  1, 2), sequence of tokens generated by generator
    #         h: (1, batch_size, hidden_dim), lstm hidden state
    #         c: (1, batch_size, hidden_dim), lstm cell state
    #     """
    #     x = input[:, 0, 0]
    #     mask = input[:, 0, 1].float()
    #     emb = self.emb(x) * mask.unsqueeze(2)
    #     output, (h, c) = self.lstm(emb, (h, c))
    #     pred = F.softmax(self.fc(output.view(-1, self.args.hidden_dim)), dim=1)
    #     return pred, h, c

        